<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>并行编程之内存管理(总结) | Sky&#39;s Blog</title>
<meta name="keywords" content="">
<meta name="description" content="这篇总结并行编程的三种常见的内存管理方法，三种方法如下：
Reference Counting：并行编程之内存管理(一) Hazard Pointer：并行编程之内存管理(二) RCU：并行编程之内存管理(三) 三种方法各有利弊，优缺点对比如下：
引用计数(Reference Counting) Hazard Pointer RCU 读性能 低，不可扩展 高，可扩展 高，可扩展 可保护的对象数量 可扩展 不可扩展 可扩展 保护周期 支持长周期 支持长周期 用户必须限制保护周期长度 遍历是否需要重试 如果和删除冲突需要重试 如果和删除冲突需要重试 不需要 存在性保证 复杂 保证 保证 读竞争 高 无 无 对象遍历开销 CAS原子操作，内存屏障，cache missing 内存屏障 无 读遍历机制 无锁 无锁 有限制的无等待(wait free) 读引用获取 可能失败 可能失败 不会失败 内存开销 有限 有限 无限 内存回收机制 无锁 无锁 阻塞 自动回收 是 部分 部分 已经有很多C&#43;&#43;项目，包括开源和大厂内部项目，都开始采用Hazard Pointer和RCU来实现并发数据结构，而且C&#43;&#43;标准委员会也已经在讨论将这两个组件加入到C&#43;&#43;26标准中。
时代在变，并行编程技术也在突飞猛进。多线程多核(multi-core)技术，甚至甚多核(many-core)技术都在飞速发展，加上各种并行编程范式的应用，可以预见到在一段时期内，并行编程将面临百花齐放，技术爆发的局面。">
<meta name="author" content="">
<link rel="canonical" href="https://skyan.github.io/posts/parallel-programming-4/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css" integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z&#43;V9&#43;cO1A=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://skyan.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://skyan.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://skyan.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://skyan.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://skyan.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://skyan.github.io/posts/parallel-programming-4/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
  

<meta property="og:title" content="并行编程之内存管理(总结)" />
<meta property="og:description" content="这篇总结并行编程的三种常见的内存管理方法，三种方法如下：
Reference Counting：并行编程之内存管理(一) Hazard Pointer：并行编程之内存管理(二) RCU：并行编程之内存管理(三) 三种方法各有利弊，优缺点对比如下：
引用计数(Reference Counting) Hazard Pointer RCU 读性能 低，不可扩展 高，可扩展 高，可扩展 可保护的对象数量 可扩展 不可扩展 可扩展 保护周期 支持长周期 支持长周期 用户必须限制保护周期长度 遍历是否需要重试 如果和删除冲突需要重试 如果和删除冲突需要重试 不需要 存在性保证 复杂 保证 保证 读竞争 高 无 无 对象遍历开销 CAS原子操作，内存屏障，cache missing 内存屏障 无 读遍历机制 无锁 无锁 有限制的无等待(wait free) 读引用获取 可能失败 可能失败 不会失败 内存开销 有限 有限 无限 内存回收机制 无锁 无锁 阻塞 自动回收 是 部分 部分 已经有很多C&#43;&#43;项目，包括开源和大厂内部项目，都开始采用Hazard Pointer和RCU来实现并发数据结构，而且C&#43;&#43;标准委员会也已经在讨论将这两个组件加入到C&#43;&#43;26标准中。
时代在变，并行编程技术也在突飞猛进。多线程多核(multi-core)技术，甚至甚多核(many-core)技术都在飞速发展，加上各种并行编程范式的应用，可以预见到在一段时期内，并行编程将面临百花齐放，技术爆发的局面。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://skyan.github.io/posts/parallel-programming-4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-06-14T19:25:10+08:00" />
<meta property="article:modified_time" content="2022-06-14T19:25:10+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="并行编程之内存管理(总结)"/>
<meta name="twitter:description" content="这篇总结并行编程的三种常见的内存管理方法，三种方法如下：
Reference Counting：并行编程之内存管理(一) Hazard Pointer：并行编程之内存管理(二) RCU：并行编程之内存管理(三) 三种方法各有利弊，优缺点对比如下：
引用计数(Reference Counting) Hazard Pointer RCU 读性能 低，不可扩展 高，可扩展 高，可扩展 可保护的对象数量 可扩展 不可扩展 可扩展 保护周期 支持长周期 支持长周期 用户必须限制保护周期长度 遍历是否需要重试 如果和删除冲突需要重试 如果和删除冲突需要重试 不需要 存在性保证 复杂 保证 保证 读竞争 高 无 无 对象遍历开销 CAS原子操作，内存屏障，cache missing 内存屏障 无 读遍历机制 无锁 无锁 有限制的无等待(wait free) 读引用获取 可能失败 可能失败 不会失败 内存开销 有限 有限 无限 内存回收机制 无锁 无锁 阻塞 自动回收 是 部分 部分 已经有很多C&#43;&#43;项目，包括开源和大厂内部项目，都开始采用Hazard Pointer和RCU来实现并发数据结构，而且C&#43;&#43;标准委员会也已经在讨论将这两个组件加入到C&#43;&#43;26标准中。
时代在变，并行编程技术也在突飞猛进。多线程多核(multi-core)技术，甚至甚多核(many-core)技术都在飞速发展，加上各种并行编程范式的应用，可以预见到在一段时期内，并行编程将面临百花齐放，技术爆发的局面。"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://skyan.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "并行编程之内存管理(总结)",
      "item": "https://skyan.github.io/posts/parallel-programming-4/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "并行编程之内存管理(总结)",
  "name": "并行编程之内存管理(总结)",
  "description": "这篇总结并行编程的三种常见的内存管理方法，三种方法如下：\nReference Counting：并行编程之内存管理(一) Hazard Pointer：并行编程之内存管理(二) RCU：并行编程之内存管理(三) 三种方法各有利弊，优缺点对比如下：\n引用计数(Reference Counting) Hazard Pointer RCU 读性能 低，不可扩展 高，可扩展 高，可扩展 可保护的对象数量 可扩展 不可扩展 可扩展 保护周期 支持长周期 支持长周期 用户必须限制保护周期长度 遍历是否需要重试 如果和删除冲突需要重试 如果和删除冲突需要重试 不需要 存在性保证 复杂 保证 保证 读竞争 高 无 无 对象遍历开销 CAS原子操作，内存屏障，cache missing 内存屏障 无 读遍历机制 无锁 无锁 有限制的无等待(wait free) 读引用获取 可能失败 可能失败 不会失败 内存开销 有限 有限 无限 内存回收机制 无锁 无锁 阻塞 自动回收 是 部分 部分 已经有很多C++项目，包括开源和大厂内部项目，都开始采用Hazard Pointer和RCU来实现并发数据结构，而且C++标准委员会也已经在讨论将这两个组件加入到C++26标准中。\n时代在变，并行编程技术也在突飞猛进。多线程多核(multi-core)技术，甚至甚多核(many-core)技术都在飞速发展，加上各种并行编程范式的应用，可以预见到在一段时期内，并行编程将面临百花齐放，技术爆发的局面。",
  "keywords": [
    
  ],
  "articleBody": "这篇总结并行编程的三种常见的内存管理方法，三种方法如下：\nReference Counting：并行编程之内存管理(一) Hazard Pointer：并行编程之内存管理(二) RCU：并行编程之内存管理(三) 三种方法各有利弊，优缺点对比如下：\n引用计数(Reference Counting) Hazard Pointer RCU 读性能 低，不可扩展 高，可扩展 高，可扩展 可保护的对象数量 可扩展 不可扩展 可扩展 保护周期 支持长周期 支持长周期 用户必须限制保护周期长度 遍历是否需要重试 如果和删除冲突需要重试 如果和删除冲突需要重试 不需要 存在性保证 复杂 保证 保证 读竞争 高 无 无 对象遍历开销 CAS原子操作，内存屏障，cache missing 内存屏障 无 读遍历机制 无锁 无锁 有限制的无等待(wait free) 读引用获取 可能失败 可能失败 不会失败 内存开销 有限 有限 无限 内存回收机制 无锁 无锁 阻塞 自动回收 是 部分 部分 已经有很多C++项目，包括开源和大厂内部项目，都开始采用Hazard Pointer和RCU来实现并发数据结构，而且C++标准委员会也已经在讨论将这两个组件加入到C++26标准中。\n时代在变，并行编程技术也在突飞猛进。多线程多核(multi-core)技术，甚至甚多核(many-core)技术都在飞速发展，加上各种并行编程范式的应用，可以预见到在一段时期内，并行编程将面临百花齐放，技术爆发的局面。\n",
  "wordCount" : "65",
  "inLanguage": "en",
  "datePublished": "2022-06-14T19:25:10+08:00",
  "dateModified": "2022-06-14T19:25:10+08:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://skyan.github.io/posts/parallel-programming-4/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Sky's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://skyan.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://skyan.github.io/" accesskey="h" title="Sky&#39;s Blog (Alt + H)">Sky&#39;s Blog</a>
            <div class="logo-switches">
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      并行编程之内存管理(总结)
    </h1>
    <div class="post-meta"><span title='2022-06-14 19:25:10 +0800 CST'>June 14, 2022</span>

</div>
  </header> 
  <div class="post-content"><p>这篇总结并行编程的三种常见的内存管理方法，三种方法如下：</p>
<ul>
<li>Reference Counting：<a href="https://skyan.github.io/posts/parallel-programming-1/">并行编程之内存管理(一)</a></li>
<li>Hazard Pointer：<a href="https://skyan.github.io/posts/parallel-programming-2/">并行编程之内存管理(二)</a></li>
<li>RCU：<a href="https://skyan.github.io/posts/parallel-programming-3/">并行编程之内存管理(三)</a></li>
</ul>
<p>三种方法各有利弊，优缺点对比如下：</p>
<table>
<thead>
<tr>
<th></th>
<th>引用计数(Reference Counting)</th>
<th>Hazard Pointer</th>
<th>RCU</th>
</tr>
</thead>
<tbody>
<tr>
<td>读性能</td>
<td>低，不可扩展</td>
<td>高，可扩展</td>
<td>高，可扩展</td>
</tr>
<tr>
<td>可保护的对象数量</td>
<td>可扩展</td>
<td>不可扩展</td>
<td>可扩展</td>
</tr>
<tr>
<td>保护周期</td>
<td>支持长周期</td>
<td>支持长周期</td>
<td>用户必须限制保护周期长度</td>
</tr>
<tr>
<td>遍历是否需要重试</td>
<td>如果和删除冲突需要重试</td>
<td>如果和删除冲突需要重试</td>
<td>不需要</td>
</tr>
<tr>
<td>存在性保证</td>
<td>复杂</td>
<td>保证</td>
<td>保证</td>
</tr>
<tr>
<td>读竞争</td>
<td>高</td>
<td>无</td>
<td>无</td>
</tr>
<tr>
<td>对象遍历开销</td>
<td>CAS原子操作，内存屏障，cache missing</td>
<td>内存屏障</td>
<td>无</td>
</tr>
<tr>
<td>读遍历机制</td>
<td>无锁</td>
<td>无锁</td>
<td>有限制的无等待(wait free)</td>
</tr>
<tr>
<td>读引用获取</td>
<td>可能失败</td>
<td>可能失败</td>
<td>不会失败</td>
</tr>
<tr>
<td>内存开销</td>
<td>有限</td>
<td>有限</td>
<td>无限</td>
</tr>
<tr>
<td>内存回收机制</td>
<td>无锁</td>
<td>无锁</td>
<td>阻塞</td>
</tr>
<tr>
<td>自动回收</td>
<td>是</td>
<td>部分</td>
<td>部分</td>
</tr>
</tbody>
</table>
<p>已经有很多C++项目，包括开源和大厂内部项目，都开始采用Hazard Pointer和RCU来实现并发数据结构，而且C++标准委员会也已经在讨论将这两个组件加入到C++26标准中。</p>
<p>时代在变，并行编程技术也在突飞猛进。多线程多核(multi-core)技术，甚至甚多核(many-core)技术都在飞速发展，加上各种并行编程范式的应用，可以预见到在一段时期内，并行编程将面临百花齐放，技术爆发的局面。</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2024 <a href="https://skyan.github.io/">Sky&#39;s Blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
</body>

</html>
